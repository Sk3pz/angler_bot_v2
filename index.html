<!DOCTYPE html>
<html lang="en" class="h-full w-full">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pond Depth Chart</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom Scrollbar to match the React app aesthetics */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #0f172a;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #475569;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fade-in {
            animation: fadeIn 0.2s ease-out forwards;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-slide-down {
            animation: slideDown 0.3s ease-out forwards;
        }

        .fish-card:hover .dotted-line {
            opacity: 1;
        }

        .fish-card:hover .mouse-icon {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 font-sans h-full w-full overflow-hidden flex flex-col">

<!-- Main Container: Fills height, handles padding internally -->
<div id="app-container" class="w-full h-full flex flex-col relative p-2 sm:p-4 transition-all duration-300">

    <!-- Header -->
    <div class="flex justify-between items-center mb-4 border-b border-slate-800 pb-2 shrink-0">
        <div>
            <h1 class="text-xl font-bold text-slate-100 flex items-center gap-2">
                <i data-lucide="map" class="text-cyan-400 w-5 h-5"></i>
                Pond Depth Chart
            </h1>
        </div>
        <div class="flex gap-2">
            <button id="btn-fit" class="px-3 py-1.5 rounded text-sm font-semibold flex items-center gap-2 bg-slate-800 text-slate-300 hover:text-white transition-colors border border-slate-700 hover:border-slate-500">
                <i data-lucide="minimize-2" class="w-3.5 h-3.5" id="icon-fit"></i> <span id="text-fit">Fit</span>
            </button>
            <button id="btn-fullscreen" class="px-3 py-1.5 rounded text-sm font-semibold flex items-center gap-2 bg-slate-800 text-slate-300 hover:text-white transition-colors border border-slate-700 hover:border-slate-500">
                <i data-lucide="maximize" class="w-3.5 h-3.5" id="icon-fullscreen"></i> <span id="text-fullscreen">Full</span>
            </button>
        </div>
    </div>

    <!-- Visual Map Viewport -->
    <!-- flex-1 min-h-0 ensures it takes all remaining height but doesn't overflow the flex container parent -->
    <div id="map-viewport" class="flex-1 min-h-0 relative w-full bg-slate-900 rounded-lg shadow-2xl border border-slate-800 select-none flex flex-col overflow-hidden">

        <!-- Scrollable Container -->
        <div class="flex-1 relative overflow-auto custom-scrollbar" id="map-scroll-container">

            <!-- Fixed Axis Overlay -->
            <!-- The height here is dynamic via JS -->
            <div class="sticky left-0 z-30 w-16 pointer-events-none float-left mr-[-4rem]" id="axis-container">
                <div class="absolute top-0 bottom-0 left-0 w-16 bg-slate-950/80 backdrop-blur-md border-r border-white/10 z-30">
                    <!-- Axis labels will be injected here -->
                </div>
            </div>

            <!-- Inner Content (Dynamic Width & Height) -->
            <div id="map-content" class="relative bg-slate-900" style="min-width: 100px;">
                <!-- Background Gradient -->
                <div class="absolute inset-0 z-0 pointer-events-none" style="background: linear-gradient(to bottom, #4fc3f7 0%, #0284c7 20%, #0f172a 50%, #000000 100%);"></div>

                <!-- Grid Lines container -->
                <div id="grid-lines-container"></div>

                <!-- Labels -->
                <div class="absolute left-20 top-0 flex items-center text-cyan-200 text-xs font-bold uppercase tracking-widest z-10 py-1">
                    <i data-lucide="waves" class="w-3 h-3 mr-1"></i> Surface
                </div>

                <!-- Abyss Label (Positioned dynamically in JS) -->
                <div id="abyss-label" class="absolute left-0 right-0 text-center text-indigo-900/30 font-black text-6xl tracking-[1rem] pointer-events-none select-none">
                    ABYSS
                </div>

                <!-- Fish Items Container -->
                <div id="fish-items-container"></div>
            </div>
        </div>

        <!-- Footer Hint -->
        <div class="bg-slate-900 border-t border-slate-800 p-1 text-center text-[10px] text-slate-500 uppercase tracking-wider z-40 shrink-0">
            <span id="loading-text">Loading data from .ron file...</span>
            <span class="hidden" id="footer-text">Scroll Horizontal & Vertical for more â€¢ Click items for details</span>
        </div>
    </div>

</div>

<!-- Fish Detail Modal -->
<div id="fish-modal" class="fixed inset-0 z-[100] flex items-center justify-center bg-black/60 backdrop-blur-sm p-4 hidden animate-fade-in">
    <div id="modal-content" class="bg-slate-900 border-2 p-6 rounded-xl shadow-2xl max-w-sm w-full relative overflow-hidden transition-all" onclick="event.stopPropagation()">
        <button id="btn-close-modal" class="absolute top-2 right-2 text-slate-400 hover:text-white z-10">
            <i data-lucide="x" class="w-5 h-5"></i>
        </button>

        <!-- Background Accent -->
        <div id="modal-accent" class="absolute -top-10 -right-10 w-32 h-32 rounded-full opacity-20 blur-2xl pointer-events-none"></div>

        <div class="flex flex-col gap-3 relative z-0">
            <div class="flex gap-2 items-center">
                <span id="modal-category" class="px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider bg-opacity-80"></span>
                <span id="modal-rarity" class="text-xs font-bold uppercase tracking-widest"></span>
            </div>

            <h2 id="modal-name" class="text-3xl font-black text-white leading-none"></h2>

            <div class="grid grid-cols-2 gap-3 mt-2">
                <div class="bg-slate-800/50 p-2 rounded border border-slate-700/50">
                    <span class="block text-[10px] text-slate-500 uppercase font-bold">Avg Weight</span>
                    <span class="text-lg font-mono text-slate-200"><span id="modal-weight"></span> <span class="text-xs text-slate-500">lbs</span></span>
                </div>
                <div class="bg-slate-800/50 p-2 rounded border border-slate-700/50">
                    <span class="block text-[10px] text-slate-500 uppercase font-bold">Base Value</span>
                    <span class="text-lg font-mono text-emerald-400">$<span id="modal-value"></span></span>
                </div>
            </div>

            <div class="flex items-center gap-4 mt-2 text-slate-300 font-mono bg-slate-800 p-3 rounded-lg border border-slate-700">
                <div>
                    <span class="block text-[10px] text-slate-500 uppercase">Min Depth</span>
                    <span class="text-xl font-bold"><span id="modal-min"></span> ft</span>
                </div>
                <div class="h-8 w-px bg-slate-600"></div>
                <div>
                    <span class="block text-[10px] text-slate-500 uppercase">Max Depth</span>
                    <span class="text-xl font-bold"><span id="modal-max"></span> ft</span>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // --- Data & State ---
    // Empty by default, populated via fetch
    let currentData = [];
    let isFitted = false;

    const DEFAULT_TOTAL_HEIGHT = 1200;
    let currentTotalHeight = DEFAULT_TOTAL_HEIGHT;

    const MIN_LANE_WIDTH = 130;
    const mapViewport = document.getElementById('map-viewport');

    // --- Styles & Constants ---

    const getCategoryStyles = (category) => {
        const c = category?.replace(/['"]+/g, '') || "Standard";
        switch(c) {
            case "Apex":
            case "Predatory":
                return { bg: "bg-rose-500", text: "text-white", border: "border-rose-600", pill: "bg-rose-700" };
            case "BaitFish":
                return { bg: "bg-emerald-400", text: "text-emerald-950", border: "border-emerald-500", pill: "bg-emerald-600/30" };
            case "Mythological":
            case "Legendary":
                return { bg: "bg-amber-400", text: "text-amber-950", border: "border-amber-500", pill: "bg-amber-600/30" };
            case "Ornamental":
                return { bg: "bg-fuchsia-400", text: "text-fuchsia-950", border: "border-fuchsia-500", pill: "bg-fuchsia-600/30" };
            case "Abyssal":
            case "Deep Sea":
                return { bg: "bg-indigo-600", text: "text-indigo-100", border: "border-indigo-400", pill: "bg-indigo-900" };
            case "BottomFeeder":
                return { bg: "bg-stone-500", text: "text-stone-100", border: "border-stone-400", pill: "bg-stone-700" };
            case "Schooling":
                return { bg: "bg-blue-400", text: "text-blue-950", border: "border-blue-500", pill: "bg-blue-600/30" };
            default:
                return { bg: "bg-sky-200", text: "text-sky-950", border: "border-sky-400", pill: "bg-sky-500/20" };
        }
    };

    const getRarityColor = (rarity) => {
        const r = (rarity?.toLowerCase() || "").replace(/['"]+/g, '');
        if (r === "mythical") return "text-amber-300";
        if (r === "legendary") return "text-orange-400";
        if (r === "elusive") return "text-purple-400";
        if (r === "rare") return "text-blue-400";
        if (r === "uncommon") return "text-green-400";
        return "text-slate-400";
    };

    const getDepthY = (depth) => {
        if (depth <= 100) {
            return (depth / 100) * (currentTotalHeight * 0.20);
        } else if (depth <= 500) {
            const base = currentTotalHeight * 0.20;
            const range = 400;
            return base + ((depth - 100) / range) * (currentTotalHeight * 0.25);
        } else if (depth <= 2000) {
            const base = currentTotalHeight * 0.45;
            const range = 1500;
            return base + ((depth - 500) / range) * (currentTotalHeight * 0.30);
        } else {
            const base = currentTotalHeight * 0.75;
            const range = 4000;
            return base + ((depth - 2000) / range) * (currentTotalHeight * 0.25);
        }
    };

    // --- Render Logic ---

    function renderMap() {
        // Recalculate height to fill screen if screen is taller than default
        if (!isFitted) {
            currentTotalHeight = Math.max(DEFAULT_TOTAL_HEIGHT, mapViewport.clientHeight);
        }

        // Sort
        const sorted = [...currentData].sort((a, b) => {
            if (a.min !== b.min) return a.min - b.min;
            return b.weight - a.weight;
        });

        // Layout Algorithm (Lanes)
        const lanes = [];
        const placedItems = sorted.map((fish) => {
            const topY = getDepthY(fish.min);
            const bottomY = getDepthY(fish.max);
            const visualHeight = Math.max(28, bottomY - topY);
            const visualBottom = topY + visualHeight;

            let assignedLane = -1;

            for (let i = 0; i < lanes.length; i++) {
                const lane = lanes[i];
                const collision = lane.some(occupied => {
                    return (topY < occupied.end + 2) && (visualBottom + 2 > occupied.start);
                });

                if (!collision) {
                    assignedLane = i;
                    lane.push({ start: topY, end: visualBottom });
                    break;
                }
            }

            if (assignedLane === -1) {
                assignedLane = lanes.length;
                lanes.push([{ start: topY, end: visualBottom }]);
            }

            return { ...fish, top: topY, height: visualHeight, lane: assignedLane };
        });

        // Set Container Dimensions
        const laneCount = lanes.length;
        const contentWidth = Math.max(100, (laneCount * MIN_LANE_WIDTH) + 80);
        const mapContent = document.getElementById('map-content');
        mapContent.style.width = `${contentWidth}px`;
        mapContent.style.height = `${currentTotalHeight}px`;

        // Adjust axis container height to match
        document.getElementById('axis-container').style.height = `${currentTotalHeight}px`;

        // Setup DOM Elements
        const fishContainer = document.getElementById('fish-items-container');
        fishContainer.innerHTML = ''; // Clear previous

        // Render Axis
        const axisContainer = document.querySelector('#axis-container > div');
        axisContainer.innerHTML = '';
        [0, 20, 50, 100, 200, 500, 1000, 2000, 3000, 4000, 5000, 6000].forEach(d => {
            const el = document.createElement('div');
            el.className = 'absolute w-full flex items-center justify-end pr-2';
            el.style.top = `${getDepthY(d)}px`;
            el.innerHTML = `<div class="w-2 h-px bg-amber-400/60 mr-1"></div><span class="text-xs text-amber-400 font-bold font-mono drop-shadow-sm">${d}</span>`;
            axisContainer.appendChild(el);
        });

        // Render Grid Lines
        const gridContainer = document.getElementById('grid-lines-container');
        gridContainer.innerHTML = '';
        [0, 100, 200, 500, 1000, 2000, 4000].forEach(d => {
            const el = document.createElement('div');
            el.className = 'absolute left-16 right-0 h-px bg-white/5 pointer-events-none';
            el.style.top = `${getDepthY(d)}px`;
            gridContainer.appendChild(el);
        });

        // Position Abyss Label
        document.getElementById('abyss-label').style.top = `${getDepthY(4500)}px`;

        // Render Fish
        placedItems.forEach((fish, i) => {
            const styles = getCategoryStyles(fish.category);
            const rarityColor = getRarityColor(fish.rarity);
            const leftPos = 64 + (fish.lane * MIN_LANE_WIDTH);

            const fishEl = document.createElement('div');
            fishEl.className = 'absolute transition-all duration-200 hover:z-50 group hover:scale-[1.02] cursor-pointer fish-card';
            fishEl.style.top = `${fish.top}px`;
            fishEl.style.height = `${fish.height}px`;
            fishEl.style.left = `${leftPos}px`;
            fishEl.style.width = `${MIN_LANE_WIDTH - 8}px`;

            // Store fish data on element for click handler
            fishEl.dataset.json = JSON.stringify(fish);
            fishEl.onclick = () => openModal(fish);

            fishEl.innerHTML = `
                    <div class="absolute top-0 h-px border-t border-dotted border-white/30 pointer-events-none opacity-0 transition-opacity dotted-line" style="width: ${leftPos}px; left: -${leftPos}px;"></div>
                    <div class="h-full w-full rounded border ${styles.bg} ${styles.border} shadow-md flex flex-col p-1.5 overflow-hidden relative">
                        <div class="flex justify-between items-start z-10">
                            <span class="font-bold text-xs leading-tight ${styles.text} line-clamp-2">${fish.name}</span>
                        </div>
                        <div class="absolute top-1.5 right-1.5 opacity-50 text-[8px] uppercase font-black ${rarityColor}">
                            ${(fish.rarity || "").substring(0, 1)}
                        </div>
                        <div class="mt-auto flex items-center justify-between opacity-80 z-10">
                            <span class="text-[9px] font-mono font-bold ${styles.text}">${fish.min}-${fish.max}'</span>
                            <i data-lucide="mouse-pointer-2" class="w-2.5 h-2.5 text-black/20 opacity-0 mouse-icon transition-opacity"></i>
                        </div>
                    </div>
                `;
            fishContainer.appendChild(fishEl);
        });

        // Re-initialize icons for new elements
        lucide.createIcons();
    }

    // --- Modal Logic ---

    function openModal(fish) {
        const styles = getCategoryStyles(fish.category);
        const rarityColor = getRarityColor(fish.rarity);

        const modal = document.getElementById('fish-modal');
        const content = document.getElementById('modal-content');
        const accent = document.getElementById('modal-accent');

        // Set content
        document.getElementById('modal-name').innerText = fish.name;
        document.getElementById('modal-category').innerText = fish.category;
        document.getElementById('modal-category').className = `px-2 py-0.5 rounded text-[10px] font-bold uppercase tracking-wider ${styles.bg} ${styles.text} bg-opacity-80`;

        document.getElementById('modal-rarity').innerText = fish.rarity;
        document.getElementById('modal-rarity').className = `text-xs font-bold uppercase tracking-widest ${rarityColor}`;

        document.getElementById('modal-weight').innerText = fish.weight.toLocaleString();
        document.getElementById('modal-value').innerText = fish.value.toLocaleString();
        document.getElementById('modal-min').innerText = fish.min;
        document.getElementById('modal-max').innerText = fish.max;

        // Set Styles
        content.className = `bg-slate-900 border-2 ${styles.border} p-6 rounded-xl shadow-2xl max-w-sm w-full relative overflow-hidden transition-all`;
        accent.className = `absolute -top-10 -right-10 w-32 h-32 rounded-full ${styles.bg} opacity-20 blur-2xl pointer-events-none`;

        modal.classList.remove('hidden');
    }

    function closeModal() {
        document.getElementById('fish-modal').classList.add('hidden');
    }

    document.getElementById('fish-modal').addEventListener('click', closeModal);
    document.getElementById('btn-close-modal').addEventListener('click', closeModal);

    // --- RON Parser ---

    function parseRonText(text) {
        // Remove comments
        text = text.replace(/\/\/.*$/gm, '');

        const fishList = [];
        let i = 0;

        // Find start of fish_types list
        const startMarker = "fish_types:";
        let idx = text.indexOf(startMarker);
        if (idx === -1) return [];

        // Move to opening '['
        idx = text.indexOf('[', idx);
        if (idx === -1) return [];
        i = idx + 1;

        let buffer = "";
        let depth = 0;

        // Iterate through the array content
        // We want to capture top-level (...) blocks inside the list
        while (i < text.length) {
            const char = text[i];

            if (char === '(') {
                if (depth === 0) buffer = ""; // Start of a new fish object
                buffer += char;
                depth++;
            } else if (char === ')') {
                buffer += char;
                depth--;
                if (depth === 0 && buffer.trim().length > 0) {
                    // We have a complete fish block in 'buffer'
                    const fish = parseFishBlock(buffer);
                    if (fish) fishList.push(fish);
                    buffer = "";
                }
            } else {
                if (depth > 0) buffer += char;
                // If depth is 0, check for end of list ']'
                if (depth === 0 && char === ']') break;
            }
            i++;
        }

        return fishList;
    }

    function parseFishBlock(block) {
        // Helper: match `key: value` where value is simple (word or quoted string)
        const getValue = (key) => {
            const regex = new RegExp(`${key}:\\s*("([^"]*)"|([a-zA-Z0-9_.]+(?!\\s*\\()))`);
            const m = block.match(regex);
            if (m) {
                return (m[2] || m[3]).replace(/['"]+/g, '');
            }
            return null;
        };

        // Helper: extract balanced sub-block for a key like `weight_range: (...)`
        const getSubBlock = (key) => {
            const startKey = `${key}:`;
            let idx = block.indexOf(startKey);
            if (idx === -1) return null;

            idx = block.indexOf('(', idx);
            if (idx === -1) return null;

            let d = 1;
            let end = idx + 1;
            while (end < block.length && d > 0) {
                if (block[end] === '(') d++;
                else if (block[end] === ')') d--;
                end++;
            }
            return block.substring(idx, end);
        };

        // Helper: Parse `min: X, max: Y, average: Z` inside a sub-block
        const parseRange = (subBlock) => {
            if (!subBlock) return null;
            const getVal = (k) => {
                const r = new RegExp(`${k}:\\s*([\\d.]+)`);
                const m = subBlock.match(r);
                return m ? parseFloat(m[1]) : 0;
            };
            return {
                min: getVal('min'),
                max: getVal('max'),
                average: getVal('average')
            };
        };

        // Helper: Parse tuple range `key: (min, max)`
        const getTupleRange = (key) => {
            // regex for `key: (val1, val2)`
            const regex = new RegExp(`${key}:\\s*\\(\\s*([\\d.]+)\\s*,\\s*([\\d.]+)(?:\\s*,\\s*[\\d.]+)?\\s*\\)`);
            const m = block.match(regex);
            if (m) return { min: parseFloat(m[1]), max: parseFloat(m[2]) };
            return null;
        };

        const name = getValue("name");
        if (!name) return null;

        const category = getValue("category") || "Standard";
        const rarity = getValue("rarity") || "Common";
        const base_value = parseFloat(getValue("base_value")) || 0;

        // Parsing structured ranges
        const depthData = getTupleRange("depth_range");
        const weightBlock = getSubBlock("weight_range");
        const weightData = parseRange(weightBlock);

        return {
            name: name,
            rarity: rarity,
            category: category,
            min: depthData ? depthData.min : 0,
            max: depthData ? depthData.max : 10,
            weight: weightData ? weightData.average : 0,
            value: base_value
        };
    }

    // --- Fetch External Data ---
    async function loadExternalData() {
        const loadingText = document.getElementById('loading-text');
        const footerText = document.getElementById('footer-text');

        console.log("Attempting to load external game data...");
        try {
            // Fetch the RON file from the specified path
            const response = await fetch('./data/gamedata/fish_types.ron');

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status} at path ${response.url}`);
            }

            const text = await response.text();
            const newFish = parseRonText(text);

            if (newFish.length > 0) {
                currentData = newFish; // Completely replace initial empty data
                renderMap();

                loadingText.classList.add('hidden');
                footerText.classList.remove('hidden');

                console.log("Successfully loaded fish data from ./data/gamedata/fish_types.ron");
            } else {
                loadingText.innerText = "Error: Parsed 0 fish from RON file.";
                console.error("Parsed 0 fish from RON file.");
            }
        } catch (err) {
            console.error("Could not load external fish data.", err);
            loadingText.innerHTML = `<span class="text-red-400">Error loading data: ${err.message}. Ensure this file is served via HTTP (not file://) and the path is correct.</span>`;
        }
    }

    // --- Fit / Zoom Out Logic ---
    const btnFit = document.getElementById('btn-fit');
    const iconFit = document.getElementById('icon-fit');
    const textFit = document.getElementById('text-fit');

    function toggleFit() {
        isFitted = !isFitted;
        if (isFitted) {
            // Set height to current container height
            const containerHeight = mapViewport.clientHeight;
            currentTotalHeight = containerHeight;

            // Update UI
            iconFit.setAttribute('data-lucide', 'expand');
            textFit.innerText = "Scroll";

            // Hide scrollbar temporarily as we fit content exactly
            document.getElementById('map-scroll-container').classList.add('overflow-hidden');
        } else {
            // Restore original height
            currentTotalHeight = DEFAULT_TOTAL_HEIGHT;

            // Update UI
            iconFit.setAttribute('data-lucide', 'minimize-2');
            textFit.innerText = "Fit";

            // Restore scrollbar
            document.getElementById('map-scroll-container').classList.remove('overflow-hidden');
        }
        renderMap();
    }

    btnFit.addEventListener('click', toggleFit);

    // --- Fullscreen Logic ---
    const btnFullscreen = document.getElementById('btn-fullscreen');
    const iconFullscreen = document.getElementById('icon-fullscreen');
    const textFullscreen = document.getElementById('text-fullscreen');

    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen().catch(() => {});
        } else {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            }
        }
    }

    function updateFullscreenUI() {
        const isFull = !!document.fullscreenElement;
        if (isFull) {
            iconFullscreen.setAttribute('data-lucide', 'minimize');
            textFullscreen.innerText = "Exit";
        } else {
            iconFullscreen.setAttribute('data-lucide', 'maximize');
            textFullscreen.innerText = "Full";
        }

        // If we are currently fitted, we need to re-measure and re-render because height changed
        if (isFitted) {
            // Small timeout to allow layout transition to settle
            setTimeout(() => {
                currentTotalHeight = mapViewport.clientHeight;
                renderMap();
            }, 50);
        }

        lucide.createIcons();
    }

    btnFullscreen.addEventListener('click', toggleFullscreen);
    document.addEventListener('fullscreenchange', updateFullscreenUI);

    // Window resize handler to adjust fit if needed
    window.addEventListener('resize', () => {
        renderMap();
    });

    // --- Init ---
    // Don't render empty map initially, just start fetching
    lucide.createIcons();
    loadExternalData();

</script>
</body>
</html>